---
import "../styles/global.css";
import Footer from "../components/footer.astro";
---

<html lang="en">
  <head>
    <title>Landing Page</title>
  </head>
  <body class="bg-white text-gray-800 font-sans relative">
    <!-- Video Background -->
    <!-- NOTE: place your file at public/assets/video.mp4 and reference "/assets/video.mp4" -->
    <video
      id="scrollVideo"
      class="fixed top-0 left-0 w-full h-full object-cover z-[-1]"
      src="/src/assets/video.mp4"
      preload="metadata"
      playsinline
      muted
      aria-hidden="true"
    ></video>

    <!-- Overlay content -->
    <main class="relative min-h-[300vh] flex flex-col items-center justify-start pt-40 space-y-40">
      <h1 class="text-5xl font-bold text-white drop-shadow-lg">Welcome to SplashKit</h1>
      <p class="text-2xl text-white drop-shadow-md max-w-3xl text-center">
        Scroll down to animate the video in the background
      </p>

      <div class="h-[100vh] w-full"></div>

      <Footer />
    </main>

    <!-- Scroll-to-video Script (client-side only) -->
    <script>
      // Get the element and ensure it's an HTMLVideoElement
      const el = document.getElementById("scrollVideo");
      const video = el instanceof HTMLVideoElement ? el : null;

      if (!video) {
        console.error("scrollVideo element not found or not a <video>.");
      } else {
        // When metadata is ready, we can control currentTime
        video.addEventListener("loadedmetadata", () => {
          // Pause native playback so we fully control time
          video.pause();

          const duration = video.duration || 0;
          let targetTime = video.currentTime || 0;
          let smoothTime = targetTime;

          // Compute target time from scroll
          const updateTargetFromScroll = () => {
            const scrollTop = window.scrollY || document.documentElement.scrollTop;
            const docHeight = Math.max(
              document.documentElement.scrollHeight,
              document.body.scrollHeight
            );
            const scrollable = Math.max(1, docHeight - window.innerHeight);
            const scrollFraction = Math.min(1, Math.max(0, scrollTop / scrollable));
            targetTime = scrollFraction * duration;
          };

          // Initial compute
          updateTargetFromScroll();

          // Listen for scroll/resize (passive to avoid blocking)
          window.addEventListener("scroll", updateTargetFromScroll, { passive: true });
          window.addEventListener("resize", updateTargetFromScroll);

          // RAF loop for smooth easing
          const ease = 0.12; // lower -> smoother/slower, higher -> snappier
          function raf() {
            // Smooth towards target
            smoothTime += (targetTime - smoothTime) * ease;

            // Avoid tiny updates
            if (Math.abs(video.currentTime - smoothTime) > 0.01) {
              try {
                video.currentTime = smoothTime;
              } catch (err) {
                // Some browsers may throw if seeking too frequently; ignore minor errors
                // console.debug("seek error", err);
              }
            }

            requestAnimationFrame(raf);
          }

          requestAnimationFrame(raf);
        });

        // Helpful dev feedback if metadata never loads:
        setTimeout(() => {
          if (!video.duration || video.duration === Infinity) {
            console.warn(
              "Video metadata not loaded or duration unknown. Check the file path (use public/assets/video.mp4) and that the video is reachable."
            );
          }
        }, 3000);
      }
    </script>
  </body>
</html>
